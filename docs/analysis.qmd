# Analysis

-   Answers to the research questions
-   Different methods considered
-   Competing approaches
-   Justifications

## Forecasting Next Year Milk Prices
```{r}
# re-arragen the df_producteur data in ascending order
df_producteur <- df_producteur[order(df_producteur$date),]

#creating tsibble for organic and non-organic milk prices
df_producteur_ts_non_bio <- ts(df_producteur$prix_non_bio, start=c(2017, 12), frequency=12)
df_producteur_ts_bio <- ts(df_producteur$prix_bio, start=c(2017, 12), frequency=12)

#convert the ts object to a tsiible object
df_producteur_ts_non_bio <- as_tsibble(df_producteur_ts_non_bio)
df_producteur_ts_bio <- as_tsibble(df_producteur_ts_bio)
```

### Naive Forecast
```{r}
# Fit a naive model
fit_non_bio <- df_producteur_ts_non_bio %>% model(naive = NAIVE(value))
fit_bio <- df_producteur_ts_bio %>% model(naive = NAIVE(value))

# Forecast the next 12 months
naive_forecast_non_bio <- fit_non_bio %>% forecast(h = 12)
naive_forecast_bio <- fit_bio %>% forecast(h = 12)

plot <- naive_forecast_non_bio %>%
  autoplot(df_producteur_ts_non_bio, alpha = 0.5) +
  labs(title = "Naive Forecast of Non-Organic Milk Prices",
       x = "Date",
       y = "Price") + guides(colour = guide_legend(title = "Forecast"))
plot
plot <- naive_forecast_bio %>%
  autoplot(df_producteur_ts_bio, alpha = 0.5) +
  labs(title = "Naive Forecast of Non-Organic Milk Prices",
       x = "Date",
       y = "Price") + guides(colour = guide_legend(title = "Forecast"))
plot
```
We observe that this model is very vague because is just a naive model that assumes that the next value will be the same as the last value. But it gives us a starting point to compare with other models.

### ARIMA Model
#### Stationarity
```{r}
# re-arragen the df_producteur data in ascending order
df_producteur <- df_producteur[order(df_producteur$date),]

#creating tsibble for organic and non-organic milk prices
df_producteur_ts_non_bio <- ts(df_producteur$prix_non_bio, start=c(2017, 12), frequency=12)
df_producteur_ts_bio <- ts(df_producteur$prix_bio, start=c(2017, 12), frequency=12)
#check for stationarity
adf.test(df_producteur_ts_non_bio)
adf.test(df_producteur_ts_bio)
```
We analyse the stationarity of the time series data for both organic and non-organic milk prices using the Augmented Dickey-Fuller (ADF) test. 
The Augmented Dickey-Fuller (ADF) test is commonly used to determine whether a unit root is present in a time series dataset. A unit root suggests that a time series is non-stationary, meaning its statistical properties such as mean and variance change over time. On the other hand, if the null hypothesis of the ADF test is rejected, it indicates that the time series is stationary.

We do that because ARIMA models require the time series data to be stationary. 

The results of the ADF test for both time series `df_producteur_ts_non_bio` and `df_producteur_ts_bio` indicate:

- Dickey-Fuller statistic value of -3
- Lag order of 4
- p-value of 0.08

Solely based on the p-values provided (0.08), we cannot conclusively determine whether the time series data df_producteur_ts_non_bio and df_producteur_ts_bio are stationary or not. They might be stationary, but further analysis or additional tests might be needed for a more definitive conclusion.

We can thus differenciate the data to make it stationary.

```{r}
#difference the time series
df_producteur_ts_non_bio_diff <- diff(df_producteur_ts_non_bio)
df_producteur_ts_bio_diff <- diff(df_producteur_ts_bio)

#plot them to see the differentiation
autoplot(df_producteur_ts_non_bio_diff)+ labs(title = "Differenced Time Series of Organic Milk Prices")
autoplot(df_producteur_ts_bio_diff) + labs(title = "Differenced Time Series of Bio Milk Prices")

#check for stationarity
adf.test(df_producteur_ts_non_bio_diff)
adf.test(df_producteur_ts_bio_diff)
```

The results of the ADF test for both differenced time series indicate:

- Dickey-Fuller statistic value of -6
- Lag order of 4
- p-value of 0.01

In this case, the p-value is smaller than the typical significance level of 0.05, indicating strong evidence against the null hypothesis. Therefore, based on the p-values provided (0.01), we can conclude that the differenced time series data are likely stationary.

This suggests that after differencing, the time series data df_producteur_ts_non_bio and df_producteur_ts_bio have become stationary, which is often desirable for various time series analysis techniques and forecasting models.

#### Fitting the ARIMA Model and Forecasting

```{r}
# Fit the ARIMA model
fit_non_bio <- auto.arima(df_producteur_ts_non_bio, seasonal = TRUE)
fit_bio <- auto.arima(df_producteur_ts_bio, seasonal = TRUE)

# Forecast the next 12 months
forecast_non_bio <- forecast(fit_non_bio, h = 12)
forecast_bio <- forecast(fit_bio, h = 12)

#show the components used for the ARIMA model
fit_non_bio %>% summary()
fit_bio %>% summary()

#plot the forecasted values
autoplot(forecast_non_bio) + labs(title = "Forecasted Prices of Non-Organic Milk")
```

```{r}
autoplot(forecast_bio) + labs(title = "Forecasted Prices of Organic Milk")
```

#### Fit a SARIMA Model

```{r}
# Fit the SARIMA model
fit_non_bio_sarima <- auto.arima(df_producteur_ts_non_bio, seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
fit_bio_sarima <- auto.arima(df_producteur_ts_bio, seasonal = TRUE, stepwise = FALSE, approximation = FALSE)

# Forecast the next 12 months
forecast_non_bio_sarima <- forecast(fit_non_bio_sarima, h = 12)
forecast_bio_sarima <- forecast(fit_bio_sarima, h = 12)

#plot the forecasted values
autoplot(forecast_non_bio_sarima) + labs(title = "Forecasted Prices of Non-Organic Milk (SARIMA)")
autoplot(forecast_bio_sarima) + labs(title = "Forecasted Prices of Organic Milk (SARIMA)")
```
#### Compare ARIMA and SARIMA forecast
##### Organic Milk SARIMA vs ARIMA
```{r}
# compare forecast_bio vs forecast_bio_sarima Model using AIC

```

##### Non-Organic Milk SARIMA vs ARIMA
```{r}
# compare forecast_non_bio vs forecast_non_bio_sarima using AIC

```

#### Forecasted Prices ARIMA

```{r}
# Create a table of the forecasted values 
forecast_table_arima <- tibble(
  Month = seq(as.Date("2023-01-01"), by = "month", length.out = 12),
  Non_Organic_Forecast = forecast_non_bio$mean,
  Bio_Forecast = forecast_bio$mean
)
#round the forecasted values
forecast_table_arima <- forecast_table_arima %>%
  mutate(across(c(Non_Organic_Forecast, Bio_Forecast), ~round(., 2)))
#show the forecasted values using reactable
reactable(
  forecast_table_arima,  
  highlight = TRUE,  # Highlight rows on hover
  defaultPageSize = 10,  # Display 10 rows per page
  paginationType = "numbers",  # Use numbers for page navigation
  searchable = TRUE,  # Make the table searchable
  sortable = TRUE,  # Allow sorting
  resizable = TRUE  # Allow column resizing
)
#plot the forecasted values
forecast_table_arima %>%
  pivot_longer(cols = c(Non_Organic_Forecast, Bio_Forecast), names_to = "Type", values_to = "Forecasted_Price") %>%
  ggplot(aes(x = Month, y = Forecasted_Price, color = Type)) +
  geom_line() +
  labs(title = "Forecasted Prices of Organic and Non-Organic Milk",
       x = "Month",
       y = "Price",
       color = "Type") +
  theme_minimal()
```
We used the mean values of the forecasted prices for both organic and non-organic milk to create a table and plot the forecasted prices for the next 12 months. The table provides a detailed view of the forecasted prices, while the plot visualizes the trend of the forecasted prices over time.

#### Forecasted Prices SARIMA

```{r}
# Create a table of the forecasted values 
forecast_table_sarima <- tibble(
  Month = seq(as.Date("2023-01-01"), by = "month", length.out = 12),
  Non_Organic_Forecast = forecast_non_bio_sarima$mean,
  Bio_Forecast = forecast_bio_sarima$mean
)
#round the forecasted values
forecast_table_sarima <- forecast_table_sarima %>%
  mutate(across(c(Non_Organic_Forecast, Bio_Forecast), ~round(., 2)))
#show the forecasted values using reactable
reactable(
  forecast_table_sarima,  
  highlight = TRUE,  # Highlight rows on hover
  defaultPageSize = 10,  # Display 10 rows per page
  paginationType = "numbers",  # Use numbers for page navigation
  searchable = TRUE,  # Make the table searchable
  sortable = TRUE,  # Allow sorting
  resizable = TRUE  # Allow column resizing
)
#plot the forecasted values
forecast_table_sarima %>%
  pivot_longer(cols = c(Non_Organic_Forecast, Bio_Forecast), names_to = "Type", values_to = "Forecasted_Price") %>%
  ggplot(aes(x = Month, y = Forecasted_Price, color = Type)) +
  geom_line() +
  labs(title = "Forecasted Prices of Organic and Non-Organic Milk",
       x = "Month",
       y = "Price",
       color = "Type") +
  theme_minimal()
```

### Exponential Smoothing

```{r}
# Fit the ETS model
fit_non_bio_ets <- ets(df_producteur_ts_non_bio)
fit_bio_ets <- ets(df_producteur_ts_bio)

# Forecast the next 12 months
forecast_non_bio_ets <- forecast(fit_non_bio_ets, h = 12)
forecast_bio_ets <- forecast(fit_bio_ets, h = 12)

#plot the forecasted values
autoplot(forecast_non_bio_ets) + labs(title = "Forecasted Prices of Non-Organic Milk (ETS)")
autoplot(forecast_bio_ets) + labs(title = "Forecasted Prices of Organic Milk (ETS)")
```

```{r}
# Create a table of the forecasted values
forecast_table_ets <- tibble(
  Month = seq(as.Date("2023-01-01"), by = "month", length.out = 12),
  Non_Organic_Forecast_ETS = forecast_non_bio_ets$mean,
  Bio_Forecast_ETS = forecast_bio_ets$mean
)
forecast_table_ets

#plot the forecasted values
forecast_table_ets %>%
  pivot_longer(cols = c(Non_Organic_Forecast_ETS, Bio_Forecast_ETS), names_to = "Type", values_to = "Forecasted_Price") %>%
  ggplot(aes(x = Month, y = Forecasted_Price, color = Type)) +
  geom_line() +
  labs(title = "Forecasted Prices of Organic and Non-Organic Milk (ETS)",
       x = "Month",
       y = "Price",
       color = "Type") +
  theme_minimal()
```

```{r}
# compare ARIMA and ETS forecast

```


## Lait Equitable Analysis

### Pareto Principle

The Pareto Principle, often known as the 80/20 rule, asserts that a small proportion of causes, inputs, or efforts usually lead to a majority of the results, outputs, or rewards. Applied to a business context where approximately 20% of the sales account for 80% of the revenues, this principle can help in identifying and focusing on the most profitable aspects of a business.

Evidence from Research:

Sales and Customer Concentration: Research has consistently shown that a significant portion of sales often comes from a minority of customers or products. For instance, an analysis across 22 different consumer packaged goods categories found an average Pareto ratio (PR) of .73, indicating that the top proportion of products/customers often account for a disproportionately high share of sales or profits 
Source - [Kim, Singh, & Winer, 2017](https://doi.org/10.1007/S11002-017-9442-5)

Decision Making and Resource Allocation: The Pareto Principle helps in decision-making by highlighting areas where the greatest impact can be achieved. For example, focusing on the top-performing products or customers can optimize resource allocation and maximize profits 
Source - [Ivančić, 2014](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2841896)

Market and Profit Concentration: Another study noted that a small number of customers are often responsible for a large portion of sales, which supports the strategic focus on these customers to boost profitability and efficiency 
Source- [McCarthy & Winer, 2018](https://doi.org/10.2139/ssrn.3264425)

Conclusion:
Applying the Pareto Principle in a business context where a minority of sales drives the majority of revenue can lead to more focused and effective business strategies, optimizing efforts towards the most profitable segments. This approach not only simplifies decision-making but also enhances resource allocation, ultimately leading to increased profitability.

#### Steps

1.  Calculating the total sales across all locations for both 2022 and 2023.
2.  Ranking locations by sales to see the cumulative contribution of each location towards the total.
3.  Identifying the point where approximately 20% of the locations contribute to around 80% of the sales.

```{python}
# Calculate the total sales for each year and the combined total to apply Pareto Principle
merged_sales_data['Combined Sales'] = merged_sales_data['Total Sales 2022'] + merged_sales_data['Total Sales 2023']

# Sort locations by combined sales
pareto_data = merged_sales_data.sort_values(by='Combined Sales', ascending=False)

# Calculate cumulative sales
pareto_data['Cumulative Sales'] = pareto_data['Combined Sales'].cumsum()

# Calculate the total of combined sales
total_combined_sales = pareto_data['Combined Sales'].sum()

# Calculate the percentage of cumulative sales
pareto_data['Cumulative Percentage'] = 100 * pareto_data['Cumulative Sales'] / total_combined_sales

# Find the point where about 20% of the locations contribute to approximately 80% of the sales
pareto_data['Location Count'] = range(1, len(pareto_data) + 1)
pareto_data['Location Percentage'] = 100 * pareto_data['Location Count'] / len(pareto_data)

# Plotting the Pareto curve
plt.figure(figsize=(12, 8))
cumulative_line = plt.plot(pareto_data['Location Percentage'], pareto_data['Cumulative Percentage'], label='Cumulative Percentage of Sales', color='b', marker='o')
plt.axhline(80.2, color='r', linestyle='dashed', linewidth=1)
plt.axvline(33.3, color='green', linestyle='dashed', linewidth=1)
plt.title('Pareto Analysis of Sales Across Locations')
plt.xlabel('Cumulative Percentage of Locations')
plt.ylabel('Cumulative Percentage of Sales')
plt.legend()
plt.grid(True)
plt.show()
```
Given this graph 33.2% of Manor locations are contributing to 80% of sales. This deviates from the typical Pareto 80/20 distribution, but it still shows a concentration of sales among a subset of stores.

#### Observations

We will identify the top 33.3% of locations based on their cumulative sales contribution. This means selecting the smallest number of locations that together account for at least 80% of the total sales.

The top-performing 33.3% of Manor locations that contribute to the majority of sales are:
```{python}
# Calculate the threshold for the top 33.3% of locations
top_third_index = int(len(pareto_data) * 0.34)

# Identifying the top 33.3% of stores contributing to at least 80% of sales
top_performing_stores = pareto_data.head(top_third_index)
top_performing_stores
```

### Understanding Success Factors of Top-Performing Stores

#### Correlating Political Parties with Milk Sales
```{r}
# Calculate correlation coefficients for each party
correlation_df <- data.frame(Party = c("PLR", "PS", "UDC", "Centre", "Verts"),
                             Correlation = sapply(merged_data[, 4:8], function(x) cor(x, merged_data$`2023`)))

# Print the correlation coefficients
print(correlation_df)

# Create a matrix of plots for each party
party_plots <- lapply(names(merged_data)[4:8], function(party) {
  ggplot(merged_data, aes_string(x = "`2023`", y = party)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE, color = "blue") +
    labs(x = "Annual Sales", y = paste(party, "Party Presence (%)"), title = paste("Correlation:", party, "Party vs. Sales")) +
    theme_minimal()
})

# Arrange the plots in a matrix layout
matrix_plot <- gridExtra::grid.arrange(grobs = party_plots, ncol = 2)
matrix_plot
```

