# Data

```{r, echo = FALSE, message = FALSE}
source(here::here("scripts/setup.R"))
```

```{python}
import os
print(os.getcwd())  # In Python, the current working directory can be checked using the os module
import pandas as pd
```
* Sources
* Description
* Wrangling/cleaning
* Spotting mistakes and missing data (could be part of EDA too)
* Listing anomalies and outliers (could be part of EDA too)

## Swiss Producer
### Wrangling and Cleaning
```{r}
library(data.table)

file_path <- "../data/"

df_producteur <- read_excel(paste0(file_path, "lait_cru_producteur.xlsx"), sheet = 1)

df_producteur$date <- as.Date(df_producteur$date)
 library(kableExtra)
# Create a tibble with variable descriptions for df_producteur
variable_table <- tibble(
  Variable = c("Date", "prix_bio", "prix_non_bio", "delta", "Delta_pourcent"),
  Description = c(
    "The date when the prices were recorded, in a year-month-day format.",
    "The recorded price of organic milk on the given date.",
    "The recorded price of non-organic milk on the given date.",
    "The absolute difference between the organic and non-organic milk prices.",
    "The percentage difference between the organic and non-organic milk prices."
  )
)

# Display the table using kableExtra
variable_table %>%
  kbl() %>%
  kable_styling(position = "center", bootstrap_options = c("striped", "bordered", "hover", "condensed"))

```

### Description
This data set explains the Milk price to producers over time. Essential for Macro Anaylsis of the milk industry in Switzerland.

Have a look : 
```{r}
# create a new data cleaned
df_producteur_show <- df_producteur %>%
  mutate(delta = prix_bio - prix_non_bio,
         delta_pourcent = (prix_bio - prix_non_bio) / prix_non_bio * 100) %>%
  select(date, prix_bio, prix_non_bio, delta, delta_pourcent) %>%
  #round all column  to 2 decimal places
  mutate_if(is.numeric, round, 2) 

#print max and min values for delta_pourcent
# max_delta_pourcent <- max(df_producteur_show$delta_pourcent, na.rm = TRUE)
# max_delta_pourcent
# min_delta_pourcent <- min(df_producteur_show$delta_pourcent, na.rm = TRUE)
# min_delta_pourcent

#display cleaned data using reactable
library(reactable)
reactable(
  df_producteur_show,  
  columns = list(
    date = colDef(
      align = "center",  # Center align the date column
      minWidth = 150
    ),
    delta_pourcent = colDef(
      align = "right",  # Right align the price column
      style = function(value) {
        # Apply conditional formatting based on the price value
        if (value < 15) {
          color <- "green"  # Green for high prices
        } else if (value > 30) {
          color <- "red"    # Red for low prices
        } else {
          color <- "black"  # Default color for other values
        }
        list(color = color)
      }
    )
  ),
  highlight = TRUE,  # Highlight rows on hover
  defaultPageSize = 10,  # Display 10 rows per page
  paginationType = "numbers",  # Use numbers for page navigation
  searchable = TRUE,  # Make the table searchable
  sortable = TRUE,  # Allow sorting
  resizable = TRUE  # Allow column resizing
)
```

## Lait Equitable Sales 
### Dataset Sales 2023
#### Wrangling and Cleaning
```{python}
file_path = '../data/all_products_sales_per_stores_2023.xlsx'
df = pd.read_excel(file_path, sheet_name='Sheet1')

df.columns = df.columns.astype(str)
# Renaming the monthly columns for easier readability
new_column_names = {
    '2023-01-01 00:00:00': 'Jan 2023',
    '2023-02-01 00:00:00': 'Feb 2023',
    '2023-03-01 00:00:00': 'Mar 2023',
    '2023-04-01 00:00:00': 'Apr 2023',
    '2023-05-01 00:00:00': 'May 2023',
    '2023-06-01 00:00:00': 'Jun 2023',
    '2023-07-01 00:00:00': 'Jul 2023',
    '2023-08-01 00:00:00': 'Aug 2023',
    '2023-09-01 00:00:00': 'Sep 2023',
    '2023-10-01 00:00:00': 'Oct 2023',
    '2023-11-01 00:00:00': 'Nov 2023',
    '2023-12-01 00:00:00': 'Dec 2023'
}
df.rename(columns=new_column_names, inplace=True)

# Standardize city names based on the mapping provided
correct_city_names = {
    'Bâle': 'Basel',
    'Genève': 'Geneva',
    'Bienne': 'Biel/Bienne',
    'Chavannes': 'Chavannes-de-Bogis',
    'Marin': 'Marin-Epagnier',
    'Vesenaz': 'Vésenaz',
    'Yverdon': 'Yverdon-les-Bains',
    'Saint-Gall Webersbleiche': 'St. Gall'
}
df['Row Labels'] = df['Row Labels'].apply(lambda x: correct_city_names.get(x, x))
#load the dataset in R
```

#### Description
```{r}
#load python df
df_sales_2023 <- py$df

# Load necessary libraries
library(tibble)
library(kableExtra)

# Create a tibble with variable descriptions for df_manor_sales
variable_table <- tibble(
  Variable = c("Row Labels", "Monthly Columns (2023-01-01 to 2023-12-01)", "Grand Total"),
  Description = c(
    "Identifies the Manor store location by name.",
    "Each column represents sales figures for a specific month of 2023",
    "Total sales across all months of 2023 for each location"
  )
)

# Display the table using kableExtra
variable_table %>%
  kbl() %>%
  kable_styling(position = "center", bootstrap_options = c("striped", "bordered", "hover", "condensed"))

```

The dataset contains monthly sales data from different Manor store locations for the year 2023. 

Have a look : 

```{r}
# Using the provided column names correctly in the dataframe df_sales_2023
df_sales_2023_show <- df_sales_2023 %>%
  # Ensure you convert the column names to standard ones if needed
  rename(Location = `Row Labels`) %>%
  # Correctly sum the monthly sales columns from Jan 2023 to Dec 2023
  mutate(Total_Sales = rowSums(select(., `Jan 2023`:`Dec 2023`), na.rm = TRUE)) %>%
  select(Location, `Jan 2023`:`Dec 2023`, Total_Sales) %>%
  mutate_if(is.numeric, round, 2)  # round all numeric columns to 2 decimal places

# Display the data using reactable for an interactive table
reactable(
  df_sales_2023_show,  
  columns = list(
    Total_Sales = colDef(
      align = "right",
      style = function(value) {
        # Apply conditional formatting based on the total sales value
        if (value > 10000) {
          color <- "green"  # High total sales in red
        } else if (value < 5000) {
          color <- "red"  # Lower sales in green
        } else {
          color <- "black"  # Moderate sales in black
        }
        list(color = color)
      }
    )
  ),
  highlight = TRUE,  # Highlight rows on hover
  defaultPageSize = 10,  # Display 10 rows per page
  paginationType = "numbers",  # Use numbers for page navigation
  searchable = TRUE,  # Make the table searchable
  sortable = TRUE,  # Allow sorting
  resizable = TRUE  # Allow column resizing
)

```

### Dataset Sales 2022
#### Wrangling and Cleaning
```{python}
# Load the data for 2022
file_path_2022 = '../data/sales_2022.xlsx'
df_2022 = pd.read_excel(file_path_2022)

# Standardize city names based on the provided mapping
city_name_mapping = {
    'Bâle': 'Basel',
    'Genève': 'Geneva',
    'Bienne': 'Biel/Bienne',
    'Chavannes': 'Chavannes-de-Bogis',
    'Marin': 'Marin-Epagnier',
    'Vesenaz': 'Vésenaz',
    'Yverdon': 'Yverdon-les-Bains',
    'Saint-Gall Webersbleiche': 'St. Gall'
}

# Rename columns to standardize city names
df_2022.rename(columns=city_name_mapping, inplace=True)

# Pivoting the table to get total sales per location for 2022, summing across all products
sales_columns_2022 = [col for col in df_2022.columns if col not in ['Code article', 'Description article', 'Marque', 'Code Fournisseur', 'Description Fournisseur']]
df_2022_total_sales = df_2022[sales_columns_2022].sum().reset_index()
df_2022_total_sales.columns = ['Location', 'Total Sales 2022']
```

#### Description
```{r}
# Load the 2022 sales data
df_sales_2022 <- py$df_2022
# Load necessary libraries
library(tibble)
library(kableExtra)

# Create a tibble with variable descriptions for df_sales
variable_table <- tibble(
  Variable = c("Code article", "Description article", "Marque", "Code Fournisseur", "Description Fournisseur",
               "Location Columns (e.g., Ascona-Delta, Baden, Bâle, etc.)"),
  Description = c(
    "Unique identifier for each product.",
    "Descriptive name of the product.",
    "Brand of the product.",
    "Supplier code.",
    "Supplier name.",
    "Each of these columns represents sales figures for that specific location."
  )
)

# Display the table using kableExtra
variable_table %>%
  kbl() %>%
  kable_styling(position = "center", bootstrap_options = c("striped", "bordered", "hover", "condensed"))
```

The 2022 dataset has a different structure from the 2023 data. It consists of multiple products and their sales across various locations, with the following key columns

Have a look : 
```{r}
library(dplyr)
library(reactable)

# Assuming the dataframe is correctly named df_sales_2022 and is already loaded
# Ensure the dataframe is available in your R environment
print(head(df_sales_2022))

# Prepare the data by calculating the total sales per product across all locations
df_sales_2022_show <- df_sales_2022 %>%
  mutate(Total_Sales = rowSums(select(., `Ascona-Delta`:`Yverdon-les-Bains`), na.rm = TRUE)) %>%
  select(`Code article`, `Description article`, `Marque`, `Code Fournisseur`, `Description Fournisseur`, `Ascona-Delta`:`Yverdon-les-Bains`, Total_Sales) %>%
  mutate_if(is.numeric, round, 2)  # Round all numeric columns to 2 decimal places

# Display the data using reactable for an interactive and visually appealing table
reactable(
  df_sales_2022_show,
  columns = list(
    Total_Sales = colDef(
      align = "right",
      style = function(value) {
        if (value > 10000) {
          color <- "black"  # High sales volumes in red
        } else if (value < 1000) {
          color <- "black"  # Lower sales volumes in green
        } else {
          color <- "black"  # Moderate sales volumes in black
        }
        list(color = color)
      }
    ),
    `Code article` = colDef(name = "Product Code"),
    `Description article` = colDef(name = "Product Description"),
    `Marque` = colDef(name = "Brand"),
    `Code Fournisseur` = colDef(name = "Supplier Code"),
    `Description Fournisseur` = colDef(name = "Supplier Name")
  ),
  highlight = TRUE,
  defaultPageSize = 5,
  paginationType = "numbers",
  searchable = TRUE,
  sortable = TRUE,
  resizable = TRUE
)

```

#### Merging 2022 and 2023 dataset
```{python}
# Extracting the total sales for 2023 from the first dataset
df_2023_total_sales = df[['Row Labels', 'Grand Total']].rename(columns={'Row Labels': 'Location', 'Grand Total': 'Total Sales 2023'})

# Merging the 2022 and 2023 datasets on Location
merged_sales_data = pd.merge(df_2022_total_sales, df_2023_total_sales, on='Location', how='outer')

# Filling any NaN values that might have occurred due to locations present in one dataset and not the other
merged_sales_data.fillna(0, inplace=True)

# Display the merged dataset with total sales for both years
merged_sales_data.head()
```
The 2022 sales data has been aggregated and standardized for each location.
The merged dataset now shows the total sales per location for both 2022 and 2023

### Merging Political Parties and Sales
#### Wrangling and Cleaning
```{r}
# Read sales data from Excel
sales_data <- read_excel("../data/Ventes annuelles.xlsx")

# Read political party data from Excel
party_data <- read_excel("../data/partisPolitiqueManor.xlsx")

# Clean up party_data to match sales_data locations
party_data_cleaned <- party_data %>%
  mutate(Location = gsub(" ", "", Location)) %>%
  filter(Location %in% sales_data$Location)

# Calculate party presence percentages for each location
party_data_cleaned <- party_data_cleaned %>%
  mutate(PLR_Presence = PLR / (PLR + PS + UDC + Centre + Verts) * 100,
         PS_Presence = PS / (PLR + PS + UDC + Centre + Verts) * 100,
         UDC_Presence = UDC / (PLR + PS + UDC + Centre + Verts) * 100,
         Centre_Presence = Centre / (PLR + PS + UDC + Centre + Verts) * 100,
         Verts_Presence = Verts / (PLR + PS + UDC + Centre + Verts) * 100)

# Merge sales_data with party presence data
merged_data <- merge(sales_data, party_data_cleaned, by = "Location")
```
#### Description
UTILISER CODE POUR DISPLAY DATA (JAYESH)
